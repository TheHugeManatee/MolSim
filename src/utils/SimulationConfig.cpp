// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationConfig.h"

// TransformType
// 

TransformType::
TransformType (Value v)
: ::xml_schema::String (_xsd_TransformType_literals_[v])
{
}

TransformType::
TransformType (const char* v)
: ::xml_schema::String (v)
{
}

TransformType::
TransformType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

TransformType::
TransformType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

TransformType::
TransformType (const TransformType& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

TransformType& TransformType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_TransformType_literals_[v]);

  return *this;
}


// Transform
// 

const Transform::XOptional& Transform::
x () const
{
  return this->x_;
}

Transform::XOptional& Transform::
x ()
{
  return this->x_;
}

void Transform::
x (const XType& x)
{
  this->x_.set (x);
}

void Transform::
x (const XOptional& x)
{
  this->x_ = x;
}

void Transform::
x (::std::auto_ptr< XType > x)
{
  this->x_.set (x);
}

const Transform::TypeType& Transform::
type () const
{
  return this->type_.get ();
}

Transform::TypeType& Transform::
type ()
{
  return this->type_.get ();
}

void Transform::
type (const TypeType& x)
{
  this->type_.set (x);
}

void Transform::
type (::std::auto_ptr< TypeType > x)
{
  this->type_.set (x);
}

const Transform::AngleType& Transform::
angle () const
{
  return this->angle_.get ();
}

Transform::AngleType& Transform::
angle ()
{
  return this->angle_.get ();
}

void Transform::
angle (const AngleType& x)
{
  this->angle_.set (x);
}

Transform::AngleType Transform::
angle_default_value ()
{
  return AngleType (0.0);
}

const Transform::Shear01Type& Transform::
shear01 () const
{
  return this->shear01_.get ();
}

Transform::Shear01Type& Transform::
shear01 ()
{
  return this->shear01_.get ();
}

void Transform::
shear01 (const Shear01Type& x)
{
  this->shear01_.set (x);
}

Transform::Shear01Type Transform::
shear01_default_value ()
{
  return Shear01Type (0.0);
}

const Transform::Shear02Type& Transform::
shear02 () const
{
  return this->shear02_.get ();
}

Transform::Shear02Type& Transform::
shear02 ()
{
  return this->shear02_.get ();
}

void Transform::
shear02 (const Shear02Type& x)
{
  this->shear02_.set (x);
}

Transform::Shear02Type Transform::
shear02_default_value ()
{
  return Shear02Type (0.0);
}

const Transform::Shear10Type& Transform::
shear10 () const
{
  return this->shear10_.get ();
}

Transform::Shear10Type& Transform::
shear10 ()
{
  return this->shear10_.get ();
}

void Transform::
shear10 (const Shear10Type& x)
{
  this->shear10_.set (x);
}

Transform::Shear10Type Transform::
shear10_default_value ()
{
  return Shear10Type (0.0);
}

const Transform::Shear12Type& Transform::
shear12 () const
{
  return this->shear12_.get ();
}

Transform::Shear12Type& Transform::
shear12 ()
{
  return this->shear12_.get ();
}

void Transform::
shear12 (const Shear12Type& x)
{
  this->shear12_.set (x);
}

Transform::Shear12Type Transform::
shear12_default_value ()
{
  return Shear12Type (0.0);
}

const Transform::Shear20Type& Transform::
shear20 () const
{
  return this->shear20_.get ();
}

Transform::Shear20Type& Transform::
shear20 ()
{
  return this->shear20_.get ();
}

void Transform::
shear20 (const Shear20Type& x)
{
  this->shear20_.set (x);
}

Transform::Shear20Type Transform::
shear20_default_value ()
{
  return Shear20Type (0.0);
}

const Transform::Shear21Type& Transform::
shear21 () const
{
  return this->shear21_.get ();
}

Transform::Shear21Type& Transform::
shear21 ()
{
  return this->shear21_.get ();
}

void Transform::
shear21 (const Shear21Type& x)
{
  this->shear21_.set (x);
}

Transform::Shear21Type Transform::
shear21_default_value ()
{
  return Shear21Type (0.0);
}


// BoundaryConditionType
// 

BoundaryConditionType::
BoundaryConditionType (Value v)
: ::xml_schema::String (_xsd_BoundaryConditionType_literals_[v])
{
}

BoundaryConditionType::
BoundaryConditionType (const char* v)
: ::xml_schema::String (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

BoundaryConditionType::
BoundaryConditionType (const BoundaryConditionType& v,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

BoundaryConditionType& BoundaryConditionType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_BoundaryConditionType_literals_[v]);

  return *this;
}


// OutputFileType
// 

OutputFileType::
OutputFileType (Value v)
: ::xml_schema::String (_xsd_OutputFileType_literals_[v])
{
}

OutputFileType::
OutputFileType (const char* v)
: ::xml_schema::String (v)
{
}

OutputFileType::
OutputFileType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

OutputFileType::
OutputFileType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

OutputFileType::
OutputFileType (const OutputFileType& v,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

OutputFileType& OutputFileType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_OutputFileType_literals_[v]);

  return *this;
}


// ScenarioType
// 

ScenarioType::
ScenarioType (Value v)
: ::xml_schema::String (_xsd_ScenarioType_literals_[v])
{
}

ScenarioType::
ScenarioType (const char* v)
: ::xml_schema::String (v)
{
}

ScenarioType::
ScenarioType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

ScenarioType::
ScenarioType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

ScenarioType::
ScenarioType (const ScenarioType& v,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

ScenarioType& ScenarioType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_ScenarioType_literals_[v]);

  return *this;
}


// ThermostatSwitch
// 

ThermostatSwitch::
ThermostatSwitch (Value v)
: ::xml_schema::String (_xsd_ThermostatSwitch_literals_[v])
{
}

ThermostatSwitch::
ThermostatSwitch (const char* v)
: ::xml_schema::String (v)
{
}

ThermostatSwitch::
ThermostatSwitch (const ::std::string& v)
: ::xml_schema::String (v)
{
}

ThermostatSwitch::
ThermostatSwitch (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

ThermostatSwitch::
ThermostatSwitch (const ThermostatSwitch& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

ThermostatSwitch& ThermostatSwitch::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_ThermostatSwitch_literals_[v]);

  return *this;
}


// ContainerType
// 

ContainerType::
ContainerType (Value v)
: ::xml_schema::String (_xsd_ContainerType_literals_[v])
{
}

ContainerType::
ContainerType (const char* v)
: ::xml_schema::String (v)
{
}

ContainerType::
ContainerType (const ::std::string& v)
: ::xml_schema::String (v)
{
}

ContainerType::
ContainerType (const ::xml_schema::String& v)
: ::xml_schema::String (v)
{
}

ContainerType::
ContainerType (const ContainerType& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (v, f, c)
{
}

ContainerType& ContainerType::
operator= (Value v)
{
  static_cast< ::xml_schema::String& > (*this) = 
  ::xml_schema::String (_xsd_ContainerType_literals_[v]);

  return *this;
}


// BoundaryHandlingType
// 

const BoundaryHandlingType::RightType& BoundaryHandlingType::
right () const
{
  return this->right_.get ();
}

BoundaryHandlingType::RightType& BoundaryHandlingType::
right ()
{
  return this->right_.get ();
}

void BoundaryHandlingType::
right (const RightType& x)
{
  this->right_.set (x);
}

void BoundaryHandlingType::
right (::std::auto_ptr< RightType > x)
{
  this->right_.set (x);
}

const BoundaryHandlingType::LeftType& BoundaryHandlingType::
left () const
{
  return this->left_.get ();
}

BoundaryHandlingType::LeftType& BoundaryHandlingType::
left ()
{
  return this->left_.get ();
}

void BoundaryHandlingType::
left (const LeftType& x)
{
  this->left_.set (x);
}

void BoundaryHandlingType::
left (::std::auto_ptr< LeftType > x)
{
  this->left_.set (x);
}

const BoundaryHandlingType::TopType& BoundaryHandlingType::
top () const
{
  return this->top_.get ();
}

BoundaryHandlingType::TopType& BoundaryHandlingType::
top ()
{
  return this->top_.get ();
}

void BoundaryHandlingType::
top (const TopType& x)
{
  this->top_.set (x);
}

void BoundaryHandlingType::
top (::std::auto_ptr< TopType > x)
{
  this->top_.set (x);
}

const BoundaryHandlingType::BottomType& BoundaryHandlingType::
bottom () const
{
  return this->bottom_.get ();
}

BoundaryHandlingType::BottomType& BoundaryHandlingType::
bottom ()
{
  return this->bottom_.get ();
}

void BoundaryHandlingType::
bottom (const BottomType& x)
{
  this->bottom_.set (x);
}

void BoundaryHandlingType::
bottom (::std::auto_ptr< BottomType > x)
{
  this->bottom_.set (x);
}

const BoundaryHandlingType::FrontType& BoundaryHandlingType::
front () const
{
  return this->front_.get ();
}

BoundaryHandlingType::FrontType& BoundaryHandlingType::
front ()
{
  return this->front_.get ();
}

void BoundaryHandlingType::
front (const FrontType& x)
{
  this->front_.set (x);
}

void BoundaryHandlingType::
front (::std::auto_ptr< FrontType > x)
{
  this->front_.set (x);
}

const BoundaryHandlingType::BackType& BoundaryHandlingType::
back () const
{
  return this->back_.get ();
}

BoundaryHandlingType::BackType& BoundaryHandlingType::
back ()
{
  return this->back_.get ();
}

void BoundaryHandlingType::
back (const BackType& x)
{
  this->back_.set (x);
}

void BoundaryHandlingType::
back (::std::auto_ptr< BackType > x)
{
  this->back_.set (x);
}


// FloatVector
// 

const FloatVector::X0Type& FloatVector::
x0 () const
{
  return this->x0_.get ();
}

FloatVector::X0Type& FloatVector::
x0 ()
{
  return this->x0_.get ();
}

void FloatVector::
x0 (const X0Type& x)
{
  this->x0_.set (x);
}

const FloatVector::X1Type& FloatVector::
x1 () const
{
  return this->x1_.get ();
}

FloatVector::X1Type& FloatVector::
x1 ()
{
  return this->x1_.get ();
}

void FloatVector::
x1 (const X1Type& x)
{
  this->x1_.set (x);
}

const FloatVector::X2Type& FloatVector::
x2 () const
{
  return this->x2_.get ();
}

FloatVector::X2Type& FloatVector::
x2 ()
{
  return this->x2_.get ();
}

void FloatVector::
x2 (const X2Type& x)
{
  this->x2_.set (x);
}


// IntVector
// 

const IntVector::X0Type& IntVector::
x0 () const
{
  return this->x0_.get ();
}

IntVector::X0Type& IntVector::
x0 ()
{
  return this->x0_.get ();
}

void IntVector::
x0 (const X0Type& x)
{
  this->x0_.set (x);
}

const IntVector::X1Type& IntVector::
x1 () const
{
  return this->x1_.get ();
}

IntVector::X1Type& IntVector::
x1 ()
{
  return this->x1_.get ();
}

void IntVector::
x1 (const X1Type& x)
{
  this->x1_.set (x);
}

const IntVector::X2Type& IntVector::
x2 () const
{
  return this->x2_.get ();
}

IntVector::X2Type& IntVector::
x2 ()
{
  return this->x2_.get ();
}

void IntVector::
x2 (const X2Type& x)
{
  this->x2_.set (x);
}


// ParticleType
// 

const ParticleType::MassType& ParticleType::
mass () const
{
  return this->mass_.get ();
}

ParticleType::MassType& ParticleType::
mass ()
{
  return this->mass_.get ();
}

void ParticleType::
mass (const MassType& x)
{
  this->mass_.set (x);
}

const ParticleType::SigmaType& ParticleType::
sigma () const
{
  return this->sigma_.get ();
}

ParticleType::SigmaType& ParticleType::
sigma ()
{
  return this->sigma_.get ();
}

void ParticleType::
sigma (const SigmaType& x)
{
  this->sigma_.set (x);
}

const ParticleType::EpsilonType& ParticleType::
epsilon () const
{
  return this->epsilon_.get ();
}

ParticleType::EpsilonType& ParticleType::
epsilon ()
{
  return this->epsilon_.get ();
}

void ParticleType::
epsilon (const EpsilonType& x)
{
  this->epsilon_.set (x);
}

const ParticleType::IsMoleculeType& ParticleType::
isMolecule () const
{
  return this->isMolecule_.get ();
}

ParticleType::IsMoleculeType& ParticleType::
isMolecule ()
{
  return this->isMolecule_.get ();
}

void ParticleType::
isMolecule (const IsMoleculeType& x)
{
  this->isMolecule_.set (x);
}

ParticleType::IsMoleculeType ParticleType::
isMolecule_default_value ()
{
  return IsMoleculeType (false);
}

const ParticleType::AverageBondLengthType& ParticleType::
averageBondLength () const
{
  return this->averageBondLength_.get ();
}

ParticleType::AverageBondLengthType& ParticleType::
averageBondLength ()
{
  return this->averageBondLength_.get ();
}

void ParticleType::
averageBondLength (const AverageBondLengthType& x)
{
  this->averageBondLength_.set (x);
}

ParticleType::AverageBondLengthType ParticleType::
averageBondLength_default_value ()
{
  return AverageBondLengthType (2.2);
}

const ParticleType::StiffnessType& ParticleType::
stiffness () const
{
  return this->stiffness_.get ();
}

ParticleType::StiffnessType& ParticleType::
stiffness ()
{
  return this->stiffness_.get ();
}

void ParticleType::
stiffness (const StiffnessType& x)
{
  this->stiffness_.set (x);
}

ParticleType::StiffnessType ParticleType::
stiffness_default_value ()
{
  return StiffnessType (300.0);
}

const ParticleType::NX0Type& ParticleType::
nX0 () const
{
  return this->nX0_.get ();
}

ParticleType::NX0Type& ParticleType::
nX0 ()
{
  return this->nX0_.get ();
}

void ParticleType::
nX0 (const NX0Type& x)
{
  this->nX0_.set (x);
}

ParticleType::NX0Type ParticleType::
nX0_default_value ()
{
  return NX0Type (1.0);
}

const ParticleType::NX1Type& ParticleType::
nX1 () const
{
  return this->nX1_.get ();
}

ParticleType::NX1Type& ParticleType::
nX1 ()
{
  return this->nX1_.get ();
}

void ParticleType::
nX1 (const NX1Type& x)
{
  this->nX1_.set (x);
}

ParticleType::NX1Type ParticleType::
nX1_default_value ()
{
  return NX1Type (1.0);
}

const ParticleType::NX2Type& ParticleType::
nX2 () const
{
  return this->nX2_.get ();
}

ParticleType::NX2Type& ParticleType::
nX2 ()
{
  return this->nX2_.get ();
}

void ParticleType::
nX2 (const NX2Type& x)
{
  this->nX2_.set (x);
}

ParticleType::NX2Type ParticleType::
nX2_default_value ()
{
  return NX2Type (1.0);
}


// CutOffRadius
// 

const CutOffRadius::ScaledType& CutOffRadius::
scaled () const
{
  return this->scaled_.get ();
}

CutOffRadius::ScaledType& CutOffRadius::
scaled ()
{
  return this->scaled_.get ();
}

void CutOffRadius::
scaled (const ScaledType& x)
{
  this->scaled_.set (x);
}

const CutOffRadius::RadiusType& CutOffRadius::
radius () const
{
  return this->radius_.get ();
}

CutOffRadius::RadiusType& CutOffRadius::
radius ()
{
  return this->radius_.get ();
}

void CutOffRadius::
radius (const RadiusType& x)
{
  this->radius_.set (x);
}


// TypesList
// 

const TypesList::ParticleTypeSequence& TypesList::
particleType () const
{
  return this->particleType_;
}

TypesList::ParticleTypeSequence& TypesList::
particleType ()
{
  return this->particleType_;
}

void TypesList::
particleType (const ParticleTypeSequence& s)
{
  this->particleType_ = s;
}


// Cuboid
// 

const Cuboid::BottomLeftType& Cuboid::
bottomLeft () const
{
  return this->bottomLeft_.get ();
}

Cuboid::BottomLeftType& Cuboid::
bottomLeft ()
{
  return this->bottomLeft_.get ();
}

void Cuboid::
bottomLeft (const BottomLeftType& x)
{
  this->bottomLeft_.set (x);
}

void Cuboid::
bottomLeft (::std::auto_ptr< BottomLeftType > x)
{
  this->bottomLeft_.set (x);
}

const Cuboid::NXType& Cuboid::
nX () const
{
  return this->nX_.get ();
}

Cuboid::NXType& Cuboid::
nX ()
{
  return this->nX_.get ();
}

void Cuboid::
nX (const NXType& x)
{
  this->nX_.set (x);
}

void Cuboid::
nX (::std::auto_ptr< NXType > x)
{
  this->nX_.set (x);
}

const Cuboid::StepWidthType& Cuboid::
stepWidth () const
{
  return this->stepWidth_.get ();
}

Cuboid::StepWidthType& Cuboid::
stepWidth ()
{
  return this->stepWidth_.get ();
}

void Cuboid::
stepWidth (const StepWidthType& x)
{
  this->stepWidth_.set (x);
}

const Cuboid::TypeType& Cuboid::
type () const
{
  return this->type_.get ();
}

Cuboid::TypeType& Cuboid::
type ()
{
  return this->type_.get ();
}

void Cuboid::
type (const TypeType& x)
{
  this->type_.set (x);
}

const Cuboid::InitialVelocityType& Cuboid::
initialVelocity () const
{
  return this->initialVelocity_.get ();
}

Cuboid::InitialVelocityType& Cuboid::
initialVelocity ()
{
  return this->initialVelocity_.get ();
}

void Cuboid::
initialVelocity (const InitialVelocityType& x)
{
  this->initialVelocity_.set (x);
}

void Cuboid::
initialVelocity (::std::auto_ptr< InitialVelocityType > x)
{
  this->initialVelocity_.set (x);
}

const Cuboid::BrownianMeanVelocityOptional& Cuboid::
brownianMeanVelocity () const
{
  return this->brownianMeanVelocity_;
}

Cuboid::BrownianMeanVelocityOptional& Cuboid::
brownianMeanVelocity ()
{
  return this->brownianMeanVelocity_;
}

void Cuboid::
brownianMeanVelocity (const BrownianMeanVelocityType& x)
{
  this->brownianMeanVelocity_.set (x);
}

void Cuboid::
brownianMeanVelocity (const BrownianMeanVelocityOptional& x)
{
  this->brownianMeanVelocity_ = x;
}

const Cuboid::TransformSequence& Cuboid::
transform () const
{
  return this->transform_;
}

Cuboid::TransformSequence& Cuboid::
transform ()
{
  return this->transform_;
}

void Cuboid::
transform (const TransformSequence& s)
{
  this->transform_ = s;
}


// Sphere
// 

const Sphere::CenterType& Sphere::
center () const
{
  return this->center_.get ();
}

Sphere::CenterType& Sphere::
center ()
{
  return this->center_.get ();
}

void Sphere::
center (const CenterType& x)
{
  this->center_.set (x);
}

void Sphere::
center (::std::auto_ptr< CenterType > x)
{
  this->center_.set (x);
}

const Sphere::RadiusType& Sphere::
radius () const
{
  return this->radius_.get ();
}

Sphere::RadiusType& Sphere::
radius ()
{
  return this->radius_.get ();
}

void Sphere::
radius (const RadiusType& x)
{
  this->radius_.set (x);
}

const Sphere::StepWidthType& Sphere::
stepWidth () const
{
  return this->stepWidth_.get ();
}

Sphere::StepWidthType& Sphere::
stepWidth ()
{
  return this->stepWidth_.get ();
}

void Sphere::
stepWidth (const StepWidthType& x)
{
  this->stepWidth_.set (x);
}

const Sphere::TypeType& Sphere::
type () const
{
  return this->type_.get ();
}

Sphere::TypeType& Sphere::
type ()
{
  return this->type_.get ();
}

void Sphere::
type (const TypeType& x)
{
  this->type_.set (x);
}

const Sphere::InitialVelocityType& Sphere::
initialVelocity () const
{
  return this->initialVelocity_.get ();
}

Sphere::InitialVelocityType& Sphere::
initialVelocity ()
{
  return this->initialVelocity_.get ();
}

void Sphere::
initialVelocity (const InitialVelocityType& x)
{
  this->initialVelocity_.set (x);
}

void Sphere::
initialVelocity (::std::auto_ptr< InitialVelocityType > x)
{
  this->initialVelocity_.set (x);
}

const Sphere::BrownianMeanVelocityOptional& Sphere::
brownianMeanVelocity () const
{
  return this->brownianMeanVelocity_;
}

Sphere::BrownianMeanVelocityOptional& Sphere::
brownianMeanVelocity ()
{
  return this->brownianMeanVelocity_;
}

void Sphere::
brownianMeanVelocity (const BrownianMeanVelocityType& x)
{
  this->brownianMeanVelocity_.set (x);
}

void Sphere::
brownianMeanVelocity (const BrownianMeanVelocityOptional& x)
{
  this->brownianMeanVelocity_ = x;
}

const Sphere::TransformSequence& Sphere::
transform () const
{
  return this->transform_;
}

Sphere::TransformSequence& Sphere::
transform ()
{
  return this->transform_;
}

void Sphere::
transform (const TransformSequence& s)
{
  this->transform_ = s;
}


// Cylinder
// 

const Cylinder::BottomType& Cylinder::
bottom () const
{
  return this->bottom_.get ();
}

Cylinder::BottomType& Cylinder::
bottom ()
{
  return this->bottom_.get ();
}

void Cylinder::
bottom (const BottomType& x)
{
  this->bottom_.set (x);
}

void Cylinder::
bottom (::std::auto_ptr< BottomType > x)
{
  this->bottom_.set (x);
}

const Cylinder::HeightType& Cylinder::
height () const
{
  return this->height_.get ();
}

Cylinder::HeightType& Cylinder::
height ()
{
  return this->height_.get ();
}

void Cylinder::
height (const HeightType& x)
{
  this->height_.set (x);
}

const Cylinder::RadiusType& Cylinder::
radius () const
{
  return this->radius_.get ();
}

Cylinder::RadiusType& Cylinder::
radius ()
{
  return this->radius_.get ();
}

void Cylinder::
radius (const RadiusType& x)
{
  this->radius_.set (x);
}

const Cylinder::StepWidthType& Cylinder::
stepWidth () const
{
  return this->stepWidth_.get ();
}

Cylinder::StepWidthType& Cylinder::
stepWidth ()
{
  return this->stepWidth_.get ();
}

void Cylinder::
stepWidth (const StepWidthType& x)
{
  this->stepWidth_.set (x);
}

const Cylinder::TypeType& Cylinder::
type () const
{
  return this->type_.get ();
}

Cylinder::TypeType& Cylinder::
type ()
{
  return this->type_.get ();
}

void Cylinder::
type (const TypeType& x)
{
  this->type_.set (x);
}

const Cylinder::InitialVelocityType& Cylinder::
initialVelocity () const
{
  return this->initialVelocity_.get ();
}

Cylinder::InitialVelocityType& Cylinder::
initialVelocity ()
{
  return this->initialVelocity_.get ();
}

void Cylinder::
initialVelocity (const InitialVelocityType& x)
{
  this->initialVelocity_.set (x);
}

void Cylinder::
initialVelocity (::std::auto_ptr< InitialVelocityType > x)
{
  this->initialVelocity_.set (x);
}

const Cylinder::BrownianMeanVelocityOptional& Cylinder::
brownianMeanVelocity () const
{
  return this->brownianMeanVelocity_;
}

Cylinder::BrownianMeanVelocityOptional& Cylinder::
brownianMeanVelocity ()
{
  return this->brownianMeanVelocity_;
}

void Cylinder::
brownianMeanVelocity (const BrownianMeanVelocityType& x)
{
  this->brownianMeanVelocity_.set (x);
}

void Cylinder::
brownianMeanVelocity (const BrownianMeanVelocityOptional& x)
{
  this->brownianMeanVelocity_ = x;
}

const Cylinder::TransformSequence& Cylinder::
transform () const
{
  return this->transform_;
}

Cylinder::TransformSequence& Cylinder::
transform ()
{
  return this->transform_;
}

void Cylinder::
transform (const TransformSequence& s)
{
  this->transform_ = s;
}


// Generator
// 

const Generator::CuboidSequence& Generator::
cuboid () const
{
  return this->cuboid_;
}

Generator::CuboidSequence& Generator::
cuboid ()
{
  return this->cuboid_;
}

void Generator::
cuboid (const CuboidSequence& s)
{
  this->cuboid_ = s;
}

const Generator::SphereSequence& Generator::
sphere () const
{
  return this->sphere_;
}

Generator::SphereSequence& Generator::
sphere ()
{
  return this->sphere_;
}

void Generator::
sphere (const SphereSequence& s)
{
  this->sphere_ = s;
}

const Generator::CylinderSequence& Generator::
cylinder () const
{
  return this->cylinder_;
}

Generator::CylinderSequence& Generator::
cylinder ()
{
  return this->cylinder_;
}

void Generator::
cylinder (const CylinderSequence& s)
{
  this->cylinder_ = s;
}


// ThermostatSettings
// 

const ThermostatSettings::InitTemperatureOptional& ThermostatSettings::
initTemperature () const
{
  return this->initTemperature_;
}

ThermostatSettings::InitTemperatureOptional& ThermostatSettings::
initTemperature ()
{
  return this->initTemperature_;
}

void ThermostatSettings::
initTemperature (const InitTemperatureType& x)
{
  this->initTemperature_.set (x);
}

void ThermostatSettings::
initTemperature (const InitTemperatureOptional& x)
{
  this->initTemperature_ = x;
}

const ThermostatSettings::TargetTemperatureOptional& ThermostatSettings::
targetTemperature () const
{
  return this->targetTemperature_;
}

ThermostatSettings::TargetTemperatureOptional& ThermostatSettings::
targetTemperature ()
{
  return this->targetTemperature_;
}

void ThermostatSettings::
targetTemperature (const TargetTemperatureType& x)
{
  this->targetTemperature_.set (x);
}

void ThermostatSettings::
targetTemperature (const TargetTemperatureOptional& x)
{
  this->targetTemperature_ = x;
}

const ThermostatSettings::ControlIntervalType& ThermostatSettings::
controlInterval () const
{
  return this->controlInterval_.get ();
}

ThermostatSettings::ControlIntervalType& ThermostatSettings::
controlInterval ()
{
  return this->controlInterval_.get ();
}

void ThermostatSettings::
controlInterval (const ControlIntervalType& x)
{
  this->controlInterval_.set (x);
}

const ThermostatSettings::EstimatedStepsOptional& ThermostatSettings::
estimatedSteps () const
{
  return this->estimatedSteps_;
}

ThermostatSettings::EstimatedStepsOptional& ThermostatSettings::
estimatedSteps ()
{
  return this->estimatedSteps_;
}

void ThermostatSettings::
estimatedSteps (const EstimatedStepsType& x)
{
  this->estimatedSteps_.set (x);
}

void ThermostatSettings::
estimatedSteps (const EstimatedStepsOptional& x)
{
  this->estimatedSteps_ = x;
}

const ThermostatSettings::MaxStepsOptional& ThermostatSettings::
maxSteps () const
{
  return this->maxSteps_;
}

ThermostatSettings::MaxStepsOptional& ThermostatSettings::
maxSteps ()
{
  return this->maxSteps_;
}

void ThermostatSettings::
maxSteps (const MaxStepsType& x)
{
  this->maxSteps_.set (x);
}

void ThermostatSettings::
maxSteps (const MaxStepsOptional& x)
{
  this->maxSteps_ = x;
}


// ForceField
// 

const ForceField::TypeType& ForceField::
type () const
{
  return this->type_.get ();
}

ForceField::TypeType& ForceField::
type ()
{
  return this->type_.get ();
}

void ForceField::
type (const TypeType& x)
{
  this->type_.set (x);
}

const ForceField::FromType& ForceField::
from () const
{
  return this->from_.get ();
}

ForceField::FromType& ForceField::
from ()
{
  return this->from_.get ();
}

void ForceField::
from (const FromType& x)
{
  this->from_.set (x);
}

void ForceField::
from (::std::auto_ptr< FromType > x)
{
  this->from_.set (x);
}

const ForceField::ToType& ForceField::
to () const
{
  return this->to_.get ();
}

ForceField::ToType& ForceField::
to ()
{
  return this->to_.get ();
}

void ForceField::
to (const ToType& x)
{
  this->to_.set (x);
}

void ForceField::
to (::std::auto_ptr< ToType > x)
{
  this->to_.set (x);
}

const ForceField::ForceType& ForceField::
force () const
{
  return this->force_.get ();
}

ForceField::ForceType& ForceField::
force ()
{
  return this->force_.get ();
}

void ForceField::
force (const ForceType& x)
{
  this->force_.set (x);
}

void ForceField::
force (::std::auto_ptr< ForceType > x)
{
  this->force_.set (x);
}


// DummyForConstructors
// 

const DummyForConstructors::ThermostatSettingsType& DummyForConstructors::
ThermostatSettings () const
{
  return this->ThermostatSettings_.get ();
}

DummyForConstructors::ThermostatSettingsType& DummyForConstructors::
ThermostatSettings ()
{
  return this->ThermostatSettings_.get ();
}

void DummyForConstructors::
ThermostatSettings (const ThermostatSettingsType& x)
{
  this->ThermostatSettings_.set (x);
}

void DummyForConstructors::
ThermostatSettings (::std::auto_ptr< ThermostatSettingsType > x)
{
  this->ThermostatSettings_.set (x);
}


// SimulationConfig
// 

const SimulationConfig::DeltaTType& SimulationConfig::
deltaT () const
{
  return this->deltaT_.get ();
}

SimulationConfig::DeltaTType& SimulationConfig::
deltaT ()
{
  return this->deltaT_.get ();
}

void SimulationConfig::
deltaT (const DeltaTType& x)
{
  this->deltaT_.set (x);
}

const SimulationConfig::EndTimeType& SimulationConfig::
endTime () const
{
  return this->endTime_.get ();
}

SimulationConfig::EndTimeType& SimulationConfig::
endTime ()
{
  return this->endTime_.get ();
}

void SimulationConfig::
endTime (const EndTimeType& x)
{
  this->endTime_.set (x);
}

const SimulationConfig::DimensionsOptional& SimulationConfig::
dimensions () const
{
  return this->dimensions_;
}

SimulationConfig::DimensionsOptional& SimulationConfig::
dimensions ()
{
  return this->dimensions_;
}

void SimulationConfig::
dimensions (const DimensionsType& x)
{
  this->dimensions_.set (x);
}

void SimulationConfig::
dimensions (const DimensionsOptional& x)
{
  this->dimensions_ = x;
}

const SimulationConfig::ScenarioTypeType& SimulationConfig::
scenarioType () const
{
  return this->scenarioType_.get ();
}

SimulationConfig::ScenarioTypeType& SimulationConfig::
scenarioType ()
{
  return this->scenarioType_.get ();
}

void SimulationConfig::
scenarioType (const ScenarioTypeType& x)
{
  this->scenarioType_.set (x);
}

void SimulationConfig::
scenarioType (::std::auto_ptr< ScenarioTypeType > x)
{
  this->scenarioType_.set (x);
}

const SimulationConfig::DomainSizeType& SimulationConfig::
domainSize () const
{
  return this->domainSize_.get ();
}

SimulationConfig::DomainSizeType& SimulationConfig::
domainSize ()
{
  return this->domainSize_.get ();
}

void SimulationConfig::
domainSize (const DomainSizeType& x)
{
  this->domainSize_.set (x);
}

void SimulationConfig::
domainSize (::std::auto_ptr< DomainSizeType > x)
{
  this->domainSize_.set (x);
}

const SimulationConfig::CutoffRadiusType& SimulationConfig::
cutoffRadius () const
{
  return this->cutoffRadius_.get ();
}

SimulationConfig::CutoffRadiusType& SimulationConfig::
cutoffRadius ()
{
  return this->cutoffRadius_.get ();
}

void SimulationConfig::
cutoffRadius (const CutoffRadiusType& x)
{
  this->cutoffRadius_.set (x);
}

void SimulationConfig::
cutoffRadius (::std::auto_ptr< CutoffRadiusType > x)
{
  this->cutoffRadius_.set (x);
}

const SimulationConfig::BoundaryHandlingType& SimulationConfig::
boundaryHandling () const
{
  return this->boundaryHandling_.get ();
}

SimulationConfig::BoundaryHandlingType& SimulationConfig::
boundaryHandling ()
{
  return this->boundaryHandling_.get ();
}

void SimulationConfig::
boundaryHandling (const BoundaryHandlingType& x)
{
  this->boundaryHandling_.set (x);
}

void SimulationConfig::
boundaryHandling (::std::auto_ptr< BoundaryHandlingType > x)
{
  this->boundaryHandling_.set (x);
}

const SimulationConfig::ContainerTypeType& SimulationConfig::
containerType () const
{
  return this->containerType_.get ();
}

SimulationConfig::ContainerTypeType& SimulationConfig::
containerType ()
{
  return this->containerType_.get ();
}

void SimulationConfig::
containerType (const ContainerTypeType& x)
{
  this->containerType_.set (x);
}

void SimulationConfig::
containerType (::std::auto_ptr< ContainerTypeType > x)
{
  this->containerType_.set (x);
}

const SimulationConfig::GravitationOptional& SimulationConfig::
gravitation () const
{
  return this->gravitation_;
}

SimulationConfig::GravitationOptional& SimulationConfig::
gravitation ()
{
  return this->gravitation_;
}

void SimulationConfig::
gravitation (const GravitationType& x)
{
  this->gravitation_.set (x);
}

void SimulationConfig::
gravitation (const GravitationOptional& x)
{
  this->gravitation_ = x;
}

void SimulationConfig::
gravitation (::std::auto_ptr< GravitationType > x)
{
  this->gravitation_.set (x);
}

const SimulationConfig::OutputFrequencyType& SimulationConfig::
outputFrequency () const
{
  return this->outputFrequency_.get ();
}

SimulationConfig::OutputFrequencyType& SimulationConfig::
outputFrequency ()
{
  return this->outputFrequency_.get ();
}

void SimulationConfig::
outputFrequency (const OutputFrequencyType& x)
{
  this->outputFrequency_.set (x);
}

const SimulationConfig::DisableOutputType& SimulationConfig::
disableOutput () const
{
  return this->disableOutput_.get ();
}

SimulationConfig::DisableOutputType& SimulationConfig::
disableOutput ()
{
  return this->disableOutput_.get ();
}

void SimulationConfig::
disableOutput (const DisableOutputType& x)
{
  this->disableOutput_.set (x);
}

const SimulationConfig::LoggerConfigFileType& SimulationConfig::
loggerConfigFile () const
{
  return this->loggerConfigFile_.get ();
}

SimulationConfig::LoggerConfigFileType& SimulationConfig::
loggerConfigFile ()
{
  return this->loggerConfigFile_.get ();
}

void SimulationConfig::
loggerConfigFile (const LoggerConfigFileType& x)
{
  this->loggerConfigFile_.set (x);
}

void SimulationConfig::
loggerConfigFile (::std::auto_ptr< LoggerConfigFileType > x)
{
  this->loggerConfigFile_.set (x);
}

const SimulationConfig::OutputFilePrefixType& SimulationConfig::
outputFilePrefix () const
{
  return this->outputFilePrefix_.get ();
}

SimulationConfig::OutputFilePrefixType& SimulationConfig::
outputFilePrefix ()
{
  return this->outputFilePrefix_.get ();
}

void SimulationConfig::
outputFilePrefix (const OutputFilePrefixType& x)
{
  this->outputFilePrefix_.set (x);
}

void SimulationConfig::
outputFilePrefix (::std::auto_ptr< OutputFilePrefixType > x)
{
  this->outputFilePrefix_.set (x);
}

const SimulationConfig::OutputFileIterationOffsetOptional& SimulationConfig::
outputFileIterationOffset () const
{
  return this->outputFileIterationOffset_;
}

SimulationConfig::OutputFileIterationOffsetOptional& SimulationConfig::
outputFileIterationOffset ()
{
  return this->outputFileIterationOffset_;
}

void SimulationConfig::
outputFileIterationOffset (const OutputFileIterationOffsetType& x)
{
  this->outputFileIterationOffset_.set (x);
}

void SimulationConfig::
outputFileIterationOffset (const OutputFileIterationOffsetOptional& x)
{
  this->outputFileIterationOffset_ = x;
}

const SimulationConfig::OutputFileTypeType& SimulationConfig::
outputFileType () const
{
  return this->outputFileType_.get ();
}

SimulationConfig::OutputFileTypeType& SimulationConfig::
outputFileType ()
{
  return this->outputFileType_.get ();
}

void SimulationConfig::
outputFileType (const OutputFileTypeType& x)
{
  this->outputFileType_.set (x);
}

void SimulationConfig::
outputFileType (::std::auto_ptr< OutputFileTypeType > x)
{
  this->outputFileType_.set (x);
}

const SimulationConfig::SaveLastStateOptional& SimulationConfig::
saveLastState () const
{
  return this->saveLastState_;
}

SimulationConfig::SaveLastStateOptional& SimulationConfig::
saveLastState ()
{
  return this->saveLastState_;
}

void SimulationConfig::
saveLastState (const SaveLastStateType& x)
{
  this->saveLastState_.set (x);
}

void SimulationConfig::
saveLastState (const SaveLastStateOptional& x)
{
  this->saveLastState_ = x;
}

void SimulationConfig::
saveLastState (::std::auto_ptr< SaveLastStateType > x)
{
  this->saveLastState_.set (x);
}

const SimulationConfig::InputFileOptional& SimulationConfig::
inputFile () const
{
  return this->inputFile_;
}

SimulationConfig::InputFileOptional& SimulationConfig::
inputFile ()
{
  return this->inputFile_;
}

void SimulationConfig::
inputFile (const InputFileType& x)
{
  this->inputFile_.set (x);
}

void SimulationConfig::
inputFile (const InputFileOptional& x)
{
  this->inputFile_ = x;
}

void SimulationConfig::
inputFile (::std::auto_ptr< InputFileType > x)
{
  this->inputFile_.set (x);
}

const SimulationConfig::ThermostatSwitchOptional& SimulationConfig::
thermostatSwitch () const
{
  return this->thermostatSwitch_;
}

SimulationConfig::ThermostatSwitchOptional& SimulationConfig::
thermostatSwitch ()
{
  return this->thermostatSwitch_;
}

void SimulationConfig::
thermostatSwitch (const ThermostatSwitchType& x)
{
  this->thermostatSwitch_.set (x);
}

void SimulationConfig::
thermostatSwitch (const ThermostatSwitchOptional& x)
{
  this->thermostatSwitch_ = x;
}

void SimulationConfig::
thermostatSwitch (::std::auto_ptr< ThermostatSwitchType > x)
{
  this->thermostatSwitch_.set (x);
}

const SimulationConfig::ThermostatSettingsOptional& SimulationConfig::
thermostatSettings () const
{
  return this->thermostatSettings_;
}

SimulationConfig::ThermostatSettingsOptional& SimulationConfig::
thermostatSettings ()
{
  return this->thermostatSettings_;
}

void SimulationConfig::
thermostatSettings (const ThermostatSettingsType& x)
{
  this->thermostatSettings_.set (x);
}

void SimulationConfig::
thermostatSettings (const ThermostatSettingsOptional& x)
{
  this->thermostatSettings_ = x;
}

void SimulationConfig::
thermostatSettings (::std::auto_ptr< ThermostatSettingsType > x)
{
  this->thermostatSettings_.set (x);
}

const SimulationConfig::TypeListType& SimulationConfig::
typeList () const
{
  return this->typeList_.get ();
}

SimulationConfig::TypeListType& SimulationConfig::
typeList ()
{
  return this->typeList_.get ();
}

void SimulationConfig::
typeList (const TypeListType& x)
{
  this->typeList_.set (x);
}

void SimulationConfig::
typeList (::std::auto_ptr< TypeListType > x)
{
  this->typeList_.set (x);
}

const SimulationConfig::ForceFieldSequence& SimulationConfig::
forceField () const
{
  return this->forceField_;
}

SimulationConfig::ForceFieldSequence& SimulationConfig::
forceField ()
{
  return this->forceField_;
}

void SimulationConfig::
forceField (const ForceFieldSequence& s)
{
  this->forceField_ = s;
}

const SimulationConfig::GeneratorType& SimulationConfig::
generator () const
{
  return this->generator_.get ();
}

SimulationConfig::GeneratorType& SimulationConfig::
generator ()
{
  return this->generator_.get ();
}

void SimulationConfig::
generator (const GeneratorType& x)
{
  this->generator_.set (x);
}

void SimulationConfig::
generator (::std::auto_ptr< GeneratorType > x)
{
  this->generator_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// TransformType
//

TransformType::
TransformType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_TransformType_convert ();
}

TransformType::
TransformType (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_TransformType_convert ();
}

TransformType::
TransformType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_TransformType_convert ();
}

TransformType* TransformType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class TransformType (*this, f, c);
}

TransformType::Value TransformType::
_xsd_TransformType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TransformType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_TransformType_indexes_,
                    _xsd_TransformType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_TransformType_indexes_ + 7 || _xsd_TransformType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const TransformType::
_xsd_TransformType_literals_[7] =
{
  "scale",
  "translate",
  "rotatex0",
  "rotatex1",
  "rotatex2",
  "shear",
  "perspective"
};

const TransformType::Value TransformType::
_xsd_TransformType_indexes_[7] =
{
  ::TransformType::perspective,
  ::TransformType::rotatex0,
  ::TransformType::rotatex1,
  ::TransformType::rotatex2,
  ::TransformType::scale,
  ::TransformType::shear,
  ::TransformType::translate
};

// Transform
//

Transform::
Transform (const TypeType& type)
: ::xml_schema::Type (),
  x_ (::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  angle_ (angle_default_value (), ::xml_schema::Flags (), this),
  shear01_ (shear01_default_value (), ::xml_schema::Flags (), this),
  shear02_ (shear02_default_value (), ::xml_schema::Flags (), this),
  shear10_ (shear10_default_value (), ::xml_schema::Flags (), this),
  shear12_ (shear12_default_value (), ::xml_schema::Flags (), this),
  shear20_ (shear20_default_value (), ::xml_schema::Flags (), this),
  shear21_ (shear21_default_value (), ::xml_schema::Flags (), this)
{
}

Transform::
Transform (const Transform& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  x_ (x.x_, f, this),
  type_ (x.type_, f, this),
  angle_ (x.angle_, f, this),
  shear01_ (x.shear01_, f, this),
  shear02_ (x.shear02_, f, this),
  shear10_ (x.shear10_, f, this),
  shear12_ (x.shear12_, f, this),
  shear20_ (x.shear20_, f, this),
  shear21_ (x.shear21_, f, this)
{
}

Transform::
Transform (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  x_ (f, this),
  type_ (f, this),
  angle_ (f, this),
  shear01_ (f, this),
  shear02_ (f, this),
  shear10_ (f, this),
  shear12_ (f, this),
  shear20_ (f, this),
  shear21_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void Transform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< XType > r (
        XTraits::create (i, f, this));

      if (!this->x_)
      {
        this->x_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TypeType > r (
        TypeTraits::create (i, f, this));

      this->type_.set (r);
      continue;
    }

    if (n.name () == "angle" && n.namespace_ ().empty ())
    {
      this->angle_.set (AngleTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "shear01" && n.namespace_ ().empty ())
    {
      this->shear01_.set (Shear01Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shear02" && n.namespace_ ().empty ())
    {
      this->shear02_.set (Shear02Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shear10" && n.namespace_ ().empty ())
    {
      this->shear10_.set (Shear10Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shear12" && n.namespace_ ().empty ())
    {
      this->shear12_.set (Shear12Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shear20" && n.namespace_ ().empty ())
    {
      this->shear20_.set (Shear20Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shear21" && n.namespace_ ().empty ())
    {
      this->shear21_.set (Shear21Traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!angle_.present ())
  {
    this->angle_.set (angle_default_value ());
  }

  if (!shear01_.present ())
  {
    this->shear01_.set (shear01_default_value ());
  }

  if (!shear02_.present ())
  {
    this->shear02_.set (shear02_default_value ());
  }

  if (!shear10_.present ())
  {
    this->shear10_.set (shear10_default_value ());
  }

  if (!shear12_.present ())
  {
    this->shear12_.set (shear12_default_value ());
  }

  if (!shear20_.present ())
  {
    this->shear20_.set (shear20_default_value ());
  }

  if (!shear21_.present ())
  {
    this->shear21_.set (shear21_default_value ());
  }
}

Transform* Transform::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class Transform (*this, f, c);
}

Transform::
~Transform ()
{
}

// BoundaryConditionType
//

BoundaryConditionType::
BoundaryConditionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType::
BoundaryConditionType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType::
BoundaryConditionType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_BoundaryConditionType_convert ();
}

BoundaryConditionType* BoundaryConditionType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class BoundaryConditionType (*this, f, c);
}

BoundaryConditionType::Value BoundaryConditionType::
_xsd_BoundaryConditionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BoundaryConditionType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_BoundaryConditionType_indexes_,
                    _xsd_BoundaryConditionType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_BoundaryConditionType_indexes_ + 3 || _xsd_BoundaryConditionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const BoundaryConditionType::
_xsd_BoundaryConditionType_literals_[3] =
{
  "Outflow",
  "Reflect",
  "Periodic"
};

const BoundaryConditionType::Value BoundaryConditionType::
_xsd_BoundaryConditionType_indexes_[3] =
{
  ::BoundaryConditionType::Outflow,
  ::BoundaryConditionType::Periodic,
  ::BoundaryConditionType::Reflect
};

// OutputFileType
//

OutputFileType::
OutputFileType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_OutputFileType_convert ();
}

OutputFileType::
OutputFileType (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_OutputFileType_convert ();
}

OutputFileType::
OutputFileType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_OutputFileType_convert ();
}

OutputFileType* OutputFileType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class OutputFileType (*this, f, c);
}

OutputFileType::Value OutputFileType::
_xsd_OutputFileType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OutputFileType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_OutputFileType_indexes_,
                    _xsd_OutputFileType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_OutputFileType_indexes_ + 2 || _xsd_OutputFileType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const OutputFileType::
_xsd_OutputFileType_literals_[2] =
{
  "xyz",
  "vtk"
};

const OutputFileType::Value OutputFileType::
_xsd_OutputFileType_indexes_[2] =
{
  ::OutputFileType::vtk,
  ::OutputFileType::xyz
};

// ScenarioType
//

ScenarioType::
ScenarioType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_ScenarioType_convert ();
}

ScenarioType::
ScenarioType (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_ScenarioType_convert ();
}

ScenarioType::
ScenarioType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_ScenarioType_convert ();
}

ScenarioType* ScenarioType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class ScenarioType (*this, f, c);
}

ScenarioType::Value ScenarioType::
_xsd_ScenarioType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ScenarioType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_ScenarioType_indexes_,
                    _xsd_ScenarioType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ScenarioType_indexes_ + 3 || _xsd_ScenarioType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ScenarioType::
_xsd_ScenarioType_literals_[3] =
{
  "Gravity",
  "Lennard-Jones",
  "Membrane"
};

const ScenarioType::Value ScenarioType::
_xsd_ScenarioType_indexes_[3] =
{
  ::ScenarioType::Gravity,
  ::ScenarioType::Lennard_Jones,
  ::ScenarioType::Membrane
};

// ThermostatSwitch
//

ThermostatSwitch::
ThermostatSwitch (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_ThermostatSwitch_convert ();
}

ThermostatSwitch::
ThermostatSwitch (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_ThermostatSwitch_convert ();
}

ThermostatSwitch::
ThermostatSwitch (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_ThermostatSwitch_convert ();
}

ThermostatSwitch* ThermostatSwitch::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class ThermostatSwitch (*this, f, c);
}

ThermostatSwitch::Value ThermostatSwitch::
_xsd_ThermostatSwitch_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ThermostatSwitch_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_ThermostatSwitch_indexes_,
                    _xsd_ThermostatSwitch_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ThermostatSwitch_indexes_ + 2 || _xsd_ThermostatSwitch_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ThermostatSwitch::
_xsd_ThermostatSwitch_literals_[2] =
{
  "ON",
  "OFF"
};

const ThermostatSwitch::Value ThermostatSwitch::
_xsd_ThermostatSwitch_indexes_[2] =
{
  ::ThermostatSwitch::OFF,
  ::ThermostatSwitch::ON
};

// ContainerType
//

ContainerType::
ContainerType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (e, f, c)
{
  _xsd_ContainerType_convert ();
}

ContainerType::
ContainerType (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (a, f, c)
{
  _xsd_ContainerType_convert ();
}

ContainerType::
ContainerType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
: ::xml_schema::String (s, e, f, c)
{
  _xsd_ContainerType_convert ();
}

ContainerType* ContainerType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class ContainerType (*this, f, c);
}

ContainerType::Value ContainerType::
_xsd_ContainerType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ContainerType_literals_);
  const Value* i (::std::lower_bound (
                    _xsd_ContainerType_indexes_,
                    _xsd_ContainerType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ContainerType_indexes_ + 2 || _xsd_ContainerType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ContainerType::
_xsd_ContainerType_literals_[2] =
{
  "ParticleContainer",
  "CellListContainer"
};

const ContainerType::Value ContainerType::
_xsd_ContainerType_indexes_[2] =
{
  ::ContainerType::CellListContainer,
  ::ContainerType::ParticleContainer
};

// BoundaryHandlingType
//

BoundaryHandlingType::
BoundaryHandlingType (const RightType& right,
                      const LeftType& left,
                      const TopType& top,
                      const BottomType& bottom,
                      const FrontType& front,
                      const BackType& back)
: ::xml_schema::Type (),
  right_ (right, ::xml_schema::Flags (), this),
  left_ (left, ::xml_schema::Flags (), this),
  top_ (top, ::xml_schema::Flags (), this),
  bottom_ (bottom, ::xml_schema::Flags (), this),
  front_ (front, ::xml_schema::Flags (), this),
  back_ (back, ::xml_schema::Flags (), this)
{
}

BoundaryHandlingType::
BoundaryHandlingType (const BoundaryHandlingType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  right_ (x.right_, f, this),
  left_ (x.left_, f, this),
  top_ (x.top_, f, this),
  bottom_ (x.bottom_, f, this),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this)
{
}

BoundaryHandlingType::
BoundaryHandlingType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  right_ (f, this),
  left_ (f, this),
  top_ (f, this),
  bottom_ (f, this),
  front_ (f, this),
  back_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void BoundaryHandlingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RightType > r (
        RightTraits::create (i, f, this));

      this->right_.set (r);
      continue;
    }

    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LeftType > r (
        LeftTraits::create (i, f, this));

      this->left_.set (r);
      continue;
    }

    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TopType > r (
        TopTraits::create (i, f, this));

      this->top_.set (r);
      continue;
    }

    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BottomType > r (
        BottomTraits::create (i, f, this));

      this->bottom_.set (r);
      continue;
    }

    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FrontType > r (
        FrontTraits::create (i, f, this));

      this->front_.set (r);
      continue;
    }

    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BackType > r (
        BackTraits::create (i, f, this));

      this->back_.set (r);
      continue;
    }
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "right",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "left",
      "");
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "top",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "bottom",
      "");
  }

  if (!front_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "front",
      "");
  }

  if (!back_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "back",
      "");
  }
}

BoundaryHandlingType* BoundaryHandlingType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class BoundaryHandlingType (*this, f, c);
}

BoundaryHandlingType::
~BoundaryHandlingType ()
{
}

// FloatVector
//

FloatVector::
FloatVector (const X0Type& x0,
             const X1Type& x1,
             const X2Type& x2)
: ::xml_schema::Type (),
  x0_ (x0, ::xml_schema::Flags (), this),
  x1_ (x1, ::xml_schema::Flags (), this),
  x2_ (x2, ::xml_schema::Flags (), this)
{
}

FloatVector::
FloatVector (const FloatVector& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  x0_ (x.x0_, f, this),
  x1_ (x.x1_, f, this),
  x2_ (x.x2_, f, this)
{
}

FloatVector::
FloatVector (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  x0_ (f, this),
  x1_ (f, this),
  x2_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void FloatVector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x0" && n.namespace_ ().empty ())
    {
      this->x0_.set (X0Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x1" && n.namespace_ ().empty ())
    {
      this->x1_.set (X1Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x2" && n.namespace_ ().empty ())
    {
      this->x2_.set (X2Traits::create (i, f, this));
      continue;
    }
  }

  if (!x0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x0",
      "");
  }

  if (!x1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x1",
      "");
  }

  if (!x2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x2",
      "");
  }
}

FloatVector* FloatVector::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class FloatVector (*this, f, c);
}

FloatVector::
~FloatVector ()
{
}

// IntVector
//

IntVector::
IntVector (const X0Type& x0,
           const X1Type& x1,
           const X2Type& x2)
: ::xml_schema::Type (),
  x0_ (x0, ::xml_schema::Flags (), this),
  x1_ (x1, ::xml_schema::Flags (), this),
  x2_ (x2, ::xml_schema::Flags (), this)
{
}

IntVector::
IntVector (const IntVector& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  x0_ (x.x0_, f, this),
  x1_ (x.x1_, f, this),
  x2_ (x.x2_, f, this)
{
}

IntVector::
IntVector (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  x0_ (f, this),
  x1_ (f, this),
  x2_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void IntVector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x0" && n.namespace_ ().empty ())
    {
      this->x0_.set (X0Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x1" && n.namespace_ ().empty ())
    {
      this->x1_.set (X1Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "x2" && n.namespace_ ().empty ())
    {
      this->x2_.set (X2Traits::create (i, f, this));
      continue;
    }
  }

  if (!x0_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x0",
      "");
  }

  if (!x1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x1",
      "");
  }

  if (!x2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x2",
      "");
  }
}

IntVector* IntVector::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class IntVector (*this, f, c);
}

IntVector::
~IntVector ()
{
}

// ParticleType
//

ParticleType::
ParticleType (const MassType& mass,
              const SigmaType& sigma,
              const EpsilonType& epsilon)
: ::xml_schema::Type (),
  mass_ (mass, ::xml_schema::Flags (), this),
  sigma_ (sigma, ::xml_schema::Flags (), this),
  epsilon_ (epsilon, ::xml_schema::Flags (), this),
  isMolecule_ (isMolecule_default_value (), ::xml_schema::Flags (), this),
  averageBondLength_ (averageBondLength_default_value (), ::xml_schema::Flags (), this),
  stiffness_ (stiffness_default_value (), ::xml_schema::Flags (), this),
  nX0_ (nX0_default_value (), ::xml_schema::Flags (), this),
  nX1_ (nX1_default_value (), ::xml_schema::Flags (), this),
  nX2_ (nX2_default_value (), ::xml_schema::Flags (), this)
{
}

ParticleType::
ParticleType (const ParticleType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  mass_ (x.mass_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this),
  isMolecule_ (x.isMolecule_, f, this),
  averageBondLength_ (x.averageBondLength_, f, this),
  stiffness_ (x.stiffness_, f, this),
  nX0_ (x.nX0_, f, this),
  nX1_ (x.nX1_, f, this),
  nX2_ (x.nX2_, f, this)
{
}

ParticleType::
ParticleType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  mass_ (f, this),
  sigma_ (f, this),
  epsilon_ (f, this),
  isMolecule_ (f, this),
  averageBondLength_ (f, this),
  stiffness_ (f, this),
  nX0_ (f, this),
  nX1_ (f, this),
  nX2_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParticleType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (MassTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (SigmaTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (EpsilonTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "isMolecule" && n.namespace_ ().empty ())
    {
      this->isMolecule_.set (IsMoleculeTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "averageBondLength" && n.namespace_ ().empty ())
    {
      this->averageBondLength_.set (AverageBondLengthTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "stiffness" && n.namespace_ ().empty ())
    {
      this->stiffness_.set (StiffnessTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "nX0" && n.namespace_ ().empty ())
    {
      this->nX0_.set (NX0Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "nX1" && n.namespace_ ().empty ())
    {
      this->nX1_.set (NX1Traits::create (i, f, this));
      continue;
    }

    if (n.name () == "nX2" && n.namespace_ ().empty ())
    {
      this->nX2_.set (NX2Traits::create (i, f, this));
      continue;
    }
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mass",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "epsilon",
      "");
  }

  if (!isMolecule_.present ())
  {
    this->isMolecule_.set (isMolecule_default_value ());
  }

  if (!averageBondLength_.present ())
  {
    this->averageBondLength_.set (averageBondLength_default_value ());
  }

  if (!stiffness_.present ())
  {
    this->stiffness_.set (stiffness_default_value ());
  }

  if (!nX0_.present ())
  {
    this->nX0_.set (nX0_default_value ());
  }

  if (!nX1_.present ())
  {
    this->nX1_.set (nX1_default_value ());
  }

  if (!nX2_.present ())
  {
    this->nX2_.set (nX2_default_value ());
  }
}

ParticleType* ParticleType::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class ParticleType (*this, f, c);
}

ParticleType::
~ParticleType ()
{
}

// CutOffRadius
//

CutOffRadius::
CutOffRadius (const ScaledType& scaled,
              const RadiusType& radius)
: ::xml_schema::Type (),
  scaled_ (scaled, ::xml_schema::Flags (), this),
  radius_ (radius, ::xml_schema::Flags (), this)
{
}

CutOffRadius::
CutOffRadius (const CutOffRadius& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  scaled_ (x.scaled_, f, this),
  radius_ (x.radius_, f, this)
{
}

CutOffRadius::
CutOffRadius (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  scaled_ (f, this),
  radius_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void CutOffRadius::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "scaled" && n.namespace_ ().empty ())
    {
      this->scaled_.set (ScaledTraits::create (i, f, this));
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (RadiusTraits::create (i, f, this));
      continue;
    }
  }

  if (!scaled_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "scaled",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "radius",
      "");
  }
}

CutOffRadius* CutOffRadius::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class CutOffRadius (*this, f, c);
}

CutOffRadius::
~CutOffRadius ()
{
}

// TypesList
//

TypesList::
TypesList ()
: ::xml_schema::Type (),
  particleType_ (::xml_schema::Flags (), this)
{
}

TypesList::
TypesList (const TypesList& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  particleType_ (x.particleType_, f, this)
{
}

TypesList::
TypesList (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  particleType_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void TypesList::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particleType
    //
    if (n.name () == "particleType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ParticleTypeType > r (
        ParticleTypeTraits::create (i, f, this));

      this->particleType_.push_back (r);
      continue;
    }

    break;
  }
}

TypesList* TypesList::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class TypesList (*this, f, c);
}

TypesList::
~TypesList ()
{
}

// Cuboid
//

Cuboid::
Cuboid (const BottomLeftType& bottomLeft,
        const NXType& nX,
        const StepWidthType& stepWidth,
        const TypeType& type,
        const InitialVelocityType& initialVelocity)
: ::xml_schema::Type (),
  bottomLeft_ (bottomLeft, ::xml_schema::Flags (), this),
  nX_ (nX, ::xml_schema::Flags (), this),
  stepWidth_ (stepWidth, ::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  initialVelocity_ (initialVelocity, ::xml_schema::Flags (), this),
  brownianMeanVelocity_ (::xml_schema::Flags (), this),
  transform_ (::xml_schema::Flags (), this)
{
}

Cuboid::
Cuboid (::std::auto_ptr< BottomLeftType >& bottomLeft,
        ::std::auto_ptr< NXType >& nX,
        const StepWidthType& stepWidth,
        const TypeType& type,
        ::std::auto_ptr< InitialVelocityType >& initialVelocity)
: ::xml_schema::Type (),
  bottomLeft_ (bottomLeft, ::xml_schema::Flags (), this),
  nX_ (nX, ::xml_schema::Flags (), this),
  stepWidth_ (stepWidth, ::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  initialVelocity_ (initialVelocity, ::xml_schema::Flags (), this),
  brownianMeanVelocity_ (::xml_schema::Flags (), this),
  transform_ (::xml_schema::Flags (), this)
{
}

Cuboid::
Cuboid (const Cuboid& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  bottomLeft_ (x.bottomLeft_, f, this),
  nX_ (x.nX_, f, this),
  stepWidth_ (x.stepWidth_, f, this),
  type_ (x.type_, f, this),
  initialVelocity_ (x.initialVelocity_, f, this),
  brownianMeanVelocity_ (x.brownianMeanVelocity_, f, this),
  transform_ (x.transform_, f, this)
{
}

Cuboid::
Cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  bottomLeft_ (f, this),
  nX_ (f, this),
  stepWidth_ (f, this),
  type_ (f, this),
  initialVelocity_ (f, this),
  brownianMeanVelocity_ (f, this),
  transform_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // bottomLeft
    //
    if (n.name () == "bottomLeft" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BottomLeftType > r (
        BottomLeftTraits::create (i, f, this));

      if (!bottomLeft_.present ())
      {
        this->bottomLeft_.set (r);
        continue;
      }
    }

    // nX
    //
    if (n.name () == "nX" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NXType > r (
        NXTraits::create (i, f, this));

      if (!nX_.present ())
      {
        this->nX_.set (r);
        continue;
      }
    }

    // stepWidth
    //
    if (n.name () == "stepWidth" && n.namespace_ ().empty ())
    {
      if (!stepWidth_.present ())
      {
        this->stepWidth_.set (StepWidthTraits::create (i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    // initialVelocity
    //
    if (n.name () == "initialVelocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InitialVelocityType > r (
        InitialVelocityTraits::create (i, f, this));

      if (!initialVelocity_.present ())
      {
        this->initialVelocity_.set (r);
        continue;
      }
    }

    // brownianMeanVelocity
    //
    if (n.name () == "brownianMeanVelocity" && n.namespace_ ().empty ())
    {
      if (!this->brownianMeanVelocity_)
      {
        this->brownianMeanVelocity_.set (BrownianMeanVelocityTraits::create (i, f, this));
        continue;
      }
    }

    // transform
    //
    if (n.name () == "transform" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TransformType > r (
        TransformTraits::create (i, f, this));

      this->transform_.push_back (r);
      continue;
    }

    break;
  }

  if (!bottomLeft_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottomLeft",
      "");
  }

  if (!nX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nX",
      "");
  }

  if (!stepWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "stepWidth",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!initialVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initialVelocity",
      "");
  }
}

Cuboid* Cuboid::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class Cuboid (*this, f, c);
}

Cuboid::
~Cuboid ()
{
}

// Sphere
//

Sphere::
Sphere (const CenterType& center,
        const RadiusType& radius,
        const StepWidthType& stepWidth,
        const TypeType& type,
        const InitialVelocityType& initialVelocity)
: ::xml_schema::Type (),
  center_ (center, ::xml_schema::Flags (), this),
  radius_ (radius, ::xml_schema::Flags (), this),
  stepWidth_ (stepWidth, ::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  initialVelocity_ (initialVelocity, ::xml_schema::Flags (), this),
  brownianMeanVelocity_ (::xml_schema::Flags (), this),
  transform_ (::xml_schema::Flags (), this)
{
}

Sphere::
Sphere (::std::auto_ptr< CenterType >& center,
        const RadiusType& radius,
        const StepWidthType& stepWidth,
        const TypeType& type,
        ::std::auto_ptr< InitialVelocityType >& initialVelocity)
: ::xml_schema::Type (),
  center_ (center, ::xml_schema::Flags (), this),
  radius_ (radius, ::xml_schema::Flags (), this),
  stepWidth_ (stepWidth, ::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  initialVelocity_ (initialVelocity, ::xml_schema::Flags (), this),
  brownianMeanVelocity_ (::xml_schema::Flags (), this),
  transform_ (::xml_schema::Flags (), this)
{
}

Sphere::
Sphere (const Sphere& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  center_ (x.center_, f, this),
  radius_ (x.radius_, f, this),
  stepWidth_ (x.stepWidth_, f, this),
  type_ (x.type_, f, this),
  initialVelocity_ (x.initialVelocity_, f, this),
  brownianMeanVelocity_ (x.brownianMeanVelocity_, f, this),
  transform_ (x.transform_, f, this)
{
}

Sphere::
Sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  center_ (f, this),
  radius_ (f, this),
  stepWidth_ (f, this),
  type_ (f, this),
  initialVelocity_ (f, this),
  brownianMeanVelocity_ (f, this),
  transform_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CenterType > r (
        CenterTraits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (r);
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (RadiusTraits::create (i, f, this));
        continue;
      }
    }

    // stepWidth
    //
    if (n.name () == "stepWidth" && n.namespace_ ().empty ())
    {
      if (!stepWidth_.present ())
      {
        this->stepWidth_.set (StepWidthTraits::create (i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    // initialVelocity
    //
    if (n.name () == "initialVelocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InitialVelocityType > r (
        InitialVelocityTraits::create (i, f, this));

      if (!initialVelocity_.present ())
      {
        this->initialVelocity_.set (r);
        continue;
      }
    }

    // brownianMeanVelocity
    //
    if (n.name () == "brownianMeanVelocity" && n.namespace_ ().empty ())
    {
      if (!this->brownianMeanVelocity_)
      {
        this->brownianMeanVelocity_.set (BrownianMeanVelocityTraits::create (i, f, this));
        continue;
      }
    }

    // transform
    //
    if (n.name () == "transform" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TransformType > r (
        TransformTraits::create (i, f, this));

      this->transform_.push_back (r);
      continue;
    }

    break;
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!stepWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "stepWidth",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!initialVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initialVelocity",
      "");
  }
}

Sphere* Sphere::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class Sphere (*this, f, c);
}

Sphere::
~Sphere ()
{
}

// Cylinder
//

Cylinder::
Cylinder (const BottomType& bottom,
          const HeightType& height,
          const RadiusType& radius,
          const StepWidthType& stepWidth,
          const TypeType& type,
          const InitialVelocityType& initialVelocity)
: ::xml_schema::Type (),
  bottom_ (bottom, ::xml_schema::Flags (), this),
  height_ (height, ::xml_schema::Flags (), this),
  radius_ (radius, ::xml_schema::Flags (), this),
  stepWidth_ (stepWidth, ::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  initialVelocity_ (initialVelocity, ::xml_schema::Flags (), this),
  brownianMeanVelocity_ (::xml_schema::Flags (), this),
  transform_ (::xml_schema::Flags (), this)
{
}

Cylinder::
Cylinder (::std::auto_ptr< BottomType >& bottom,
          const HeightType& height,
          const RadiusType& radius,
          const StepWidthType& stepWidth,
          const TypeType& type,
          ::std::auto_ptr< InitialVelocityType >& initialVelocity)
: ::xml_schema::Type (),
  bottom_ (bottom, ::xml_schema::Flags (), this),
  height_ (height, ::xml_schema::Flags (), this),
  radius_ (radius, ::xml_schema::Flags (), this),
  stepWidth_ (stepWidth, ::xml_schema::Flags (), this),
  type_ (type, ::xml_schema::Flags (), this),
  initialVelocity_ (initialVelocity, ::xml_schema::Flags (), this),
  brownianMeanVelocity_ (::xml_schema::Flags (), this),
  transform_ (::xml_schema::Flags (), this)
{
}

Cylinder::
Cylinder (const Cylinder& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  bottom_ (x.bottom_, f, this),
  height_ (x.height_, f, this),
  radius_ (x.radius_, f, this),
  stepWidth_ (x.stepWidth_, f, this),
  type_ (x.type_, f, this),
  initialVelocity_ (x.initialVelocity_, f, this),
  brownianMeanVelocity_ (x.brownianMeanVelocity_, f, this),
  transform_ (x.transform_, f, this)
{
}

Cylinder::
Cylinder (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  bottom_ (f, this),
  height_ (f, this),
  radius_ (f, this),
  stepWidth_ (f, this),
  type_ (f, this),
  initialVelocity_ (f, this),
  brownianMeanVelocity_ (f, this),
  transform_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Cylinder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BottomType > r (
        BottomTraits::create (i, f, this));

      if (!bottom_.present ())
      {
        this->bottom_.set (r);
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      if (!height_.present ())
      {
        this->height_.set (HeightTraits::create (i, f, this));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (RadiusTraits::create (i, f, this));
        continue;
      }
    }

    // stepWidth
    //
    if (n.name () == "stepWidth" && n.namespace_ ().empty ())
    {
      if (!stepWidth_.present ())
      {
        this->stepWidth_.set (StepWidthTraits::create (i, f, this));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    // initialVelocity
    //
    if (n.name () == "initialVelocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InitialVelocityType > r (
        InitialVelocityTraits::create (i, f, this));

      if (!initialVelocity_.present ())
      {
        this->initialVelocity_.set (r);
        continue;
      }
    }

    // brownianMeanVelocity
    //
    if (n.name () == "brownianMeanVelocity" && n.namespace_ ().empty ())
    {
      if (!this->brownianMeanVelocity_)
      {
        this->brownianMeanVelocity_.set (BrownianMeanVelocityTraits::create (i, f, this));
        continue;
      }
    }

    // transform
    //
    if (n.name () == "transform" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TransformType > r (
        TransformTraits::create (i, f, this));

      this->transform_.push_back (r);
      continue;
    }

    break;
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "height",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!stepWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "stepWidth",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!initialVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initialVelocity",
      "");
  }
}

Cylinder* Cylinder::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class Cylinder (*this, f, c);
}

Cylinder::
~Cylinder ()
{
}

// Generator
//

Generator::
Generator ()
: ::xml_schema::Type (),
  cuboid_ (::xml_schema::Flags (), this),
  sphere_ (::xml_schema::Flags (), this),
  cylinder_ (::xml_schema::Flags (), this)
{
}

Generator::
Generator (const Generator& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  cuboid_ (x.cuboid_, f, this),
  sphere_ (x.sphere_, f, this),
  cylinder_ (x.cylinder_, f, this)
{
}

Generator::
Generator (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  cuboid_ (f, this),
  sphere_ (f, this),
  cylinder_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Generator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CuboidType > r (
        CuboidTraits::create (i, f, this));

      this->cuboid_.push_back (r);
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SphereType > r (
        SphereTraits::create (i, f, this));

      this->sphere_.push_back (r);
      continue;
    }

    // cylinder
    //
    if (n.name () == "cylinder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CylinderType > r (
        CylinderTraits::create (i, f, this));

      this->cylinder_.push_back (r);
      continue;
    }

    break;
  }
}

Generator* Generator::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class Generator (*this, f, c);
}

Generator::
~Generator ()
{
}

// ThermostatSettings
//

ThermostatSettings::
ThermostatSettings (const ControlIntervalType& controlInterval)
: ::xml_schema::Type (),
  initTemperature_ (::xml_schema::Flags (), this),
  targetTemperature_ (::xml_schema::Flags (), this),
  controlInterval_ (controlInterval, ::xml_schema::Flags (), this),
  estimatedSteps_ (::xml_schema::Flags (), this),
  maxSteps_ (::xml_schema::Flags (), this)
{
}

ThermostatSettings::
ThermostatSettings (const ThermostatSettings& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  initTemperature_ (x.initTemperature_, f, this),
  targetTemperature_ (x.targetTemperature_, f, this),
  controlInterval_ (x.controlInterval_, f, this),
  estimatedSteps_ (x.estimatedSteps_, f, this),
  maxSteps_ (x.maxSteps_, f, this)
{
}

ThermostatSettings::
ThermostatSettings (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  initTemperature_ (f, this),
  targetTemperature_ (f, this),
  controlInterval_ (f, this),
  estimatedSteps_ (f, this),
  maxSteps_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ThermostatSettings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // initTemperature
    //
    if (n.name () == "initTemperature" && n.namespace_ ().empty ())
    {
      if (!this->initTemperature_)
      {
        this->initTemperature_.set (InitTemperatureTraits::create (i, f, this));
        continue;
      }
    }

    // targetTemperature
    //
    if (n.name () == "targetTemperature" && n.namespace_ ().empty ())
    {
      if (!this->targetTemperature_)
      {
        this->targetTemperature_.set (TargetTemperatureTraits::create (i, f, this));
        continue;
      }
    }

    // controlInterval
    //
    if (n.name () == "controlInterval" && n.namespace_ ().empty ())
    {
      if (!controlInterval_.present ())
      {
        this->controlInterval_.set (ControlIntervalTraits::create (i, f, this));
        continue;
      }
    }

    // estimatedSteps
    //
    if (n.name () == "estimatedSteps" && n.namespace_ ().empty ())
    {
      if (!this->estimatedSteps_)
      {
        this->estimatedSteps_.set (EstimatedStepsTraits::create (i, f, this));
        continue;
      }
    }

    // maxSteps
    //
    if (n.name () == "maxSteps" && n.namespace_ ().empty ())
    {
      if (!this->maxSteps_)
      {
        this->maxSteps_.set (MaxStepsTraits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!controlInterval_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "controlInterval",
      "");
  }
}

ThermostatSettings* ThermostatSettings::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class ThermostatSettings (*this, f, c);
}

ThermostatSettings::
~ThermostatSettings ()
{
}

// ForceField
//

ForceField::
ForceField (const TypeType& type,
            const FromType& from,
            const ToType& to,
            const ForceType& force)
: ::xml_schema::Type (),
  type_ (type, ::xml_schema::Flags (), this),
  from_ (from, ::xml_schema::Flags (), this),
  to_ (to, ::xml_schema::Flags (), this),
  force_ (force, ::xml_schema::Flags (), this)
{
}

ForceField::
ForceField (const TypeType& type,
            ::std::auto_ptr< FromType >& from,
            ::std::auto_ptr< ToType >& to,
            ::std::auto_ptr< ForceType >& force)
: ::xml_schema::Type (),
  type_ (type, ::xml_schema::Flags (), this),
  from_ (from, ::xml_schema::Flags (), this),
  to_ (to, ::xml_schema::Flags (), this),
  force_ (force, ::xml_schema::Flags (), this)
{
}

ForceField::
ForceField (const ForceField& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  type_ (x.type_, f, this),
  from_ (x.from_, f, this),
  to_ (x.to_, f, this),
  force_ (x.force_, f, this)
{
}

ForceField::
ForceField (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  type_ (f, this),
  from_ (f, this),
  to_ (f, this),
  force_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ForceField::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      if (!type_.present ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    // from
    //
    if (n.name () == "from" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FromType > r (
        FromTraits::create (i, f, this));

      if (!from_.present ())
      {
        this->from_.set (r);
        continue;
      }
    }

    // to
    //
    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ToType > r (
        ToTraits::create (i, f, this));

      if (!to_.present ())
      {
        this->to_.set (r);
        continue;
      }
    }

    // force
    //
    if (n.name () == "force" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ForceType > r (
        ForceTraits::create (i, f, this));

      if (!force_.present ())
      {
        this->force_.set (r);
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!from_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "from",
      "");
  }

  if (!to_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "to",
      "");
  }

  if (!force_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "force",
      "");
  }
}

ForceField* ForceField::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class ForceField (*this, f, c);
}

ForceField::
~ForceField ()
{
}

// DummyForConstructors
//

DummyForConstructors::
DummyForConstructors (const ThermostatSettingsType& ThermostatSettings)
: ::xml_schema::Type (),
  ThermostatSettings_ (ThermostatSettings, ::xml_schema::Flags (), this)
{
}

DummyForConstructors::
DummyForConstructors (::std::auto_ptr< ThermostatSettingsType >& ThermostatSettings)
: ::xml_schema::Type (),
  ThermostatSettings_ (ThermostatSettings, ::xml_schema::Flags (), this)
{
}

DummyForConstructors::
DummyForConstructors (const DummyForConstructors& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  ThermostatSettings_ (x.ThermostatSettings_, f, this)
{
}

DummyForConstructors::
DummyForConstructors (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  ThermostatSettings_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void DummyForConstructors::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ThermostatSettings
    //
    if (n.name () == "ThermostatSettings" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ThermostatSettingsType > r (
        ThermostatSettingsTraits::create (i, f, this));

      if (!ThermostatSettings_.present ())
      {
        this->ThermostatSettings_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ThermostatSettings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ThermostatSettings",
      "");
  }
}

DummyForConstructors* DummyForConstructors::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class DummyForConstructors (*this, f, c);
}

DummyForConstructors::
~DummyForConstructors ()
{
}

// SimulationConfig
//

SimulationConfig::
SimulationConfig (const DeltaTType& deltaT,
                  const EndTimeType& endTime,
                  const ScenarioTypeType& scenarioType,
                  const DomainSizeType& domainSize,
                  const CutoffRadiusType& cutoffRadius,
                  const BoundaryHandlingType& boundaryHandling,
                  const ContainerTypeType& containerType,
                  const OutputFrequencyType& outputFrequency,
                  const DisableOutputType& disableOutput,
                  const LoggerConfigFileType& loggerConfigFile,
                  const OutputFilePrefixType& outputFilePrefix,
                  const OutputFileTypeType& outputFileType,
                  const TypeListType& typeList,
                  const GeneratorType& generator)
: ::xml_schema::Type (),
  deltaT_ (deltaT, ::xml_schema::Flags (), this),
  endTime_ (endTime, ::xml_schema::Flags (), this),
  dimensions_ (::xml_schema::Flags (), this),
  scenarioType_ (scenarioType, ::xml_schema::Flags (), this),
  domainSize_ (domainSize, ::xml_schema::Flags (), this),
  cutoffRadius_ (cutoffRadius, ::xml_schema::Flags (), this),
  boundaryHandling_ (boundaryHandling, ::xml_schema::Flags (), this),
  containerType_ (containerType, ::xml_schema::Flags (), this),
  gravitation_ (::xml_schema::Flags (), this),
  outputFrequency_ (outputFrequency, ::xml_schema::Flags (), this),
  disableOutput_ (disableOutput, ::xml_schema::Flags (), this),
  loggerConfigFile_ (loggerConfigFile, ::xml_schema::Flags (), this),
  outputFilePrefix_ (outputFilePrefix, ::xml_schema::Flags (), this),
  outputFileIterationOffset_ (::xml_schema::Flags (), this),
  outputFileType_ (outputFileType, ::xml_schema::Flags (), this),
  saveLastState_ (::xml_schema::Flags (), this),
  inputFile_ (::xml_schema::Flags (), this),
  thermostatSwitch_ (::xml_schema::Flags (), this),
  thermostatSettings_ (::xml_schema::Flags (), this),
  typeList_ (typeList, ::xml_schema::Flags (), this),
  forceField_ (::xml_schema::Flags (), this),
  generator_ (generator, ::xml_schema::Flags (), this)
{
}

SimulationConfig::
SimulationConfig (const DeltaTType& deltaT,
                  const EndTimeType& endTime,
                  const ScenarioTypeType& scenarioType,
                  ::std::auto_ptr< DomainSizeType >& domainSize,
                  ::std::auto_ptr< CutoffRadiusType >& cutoffRadius,
                  ::std::auto_ptr< BoundaryHandlingType >& boundaryHandling,
                  const ContainerTypeType& containerType,
                  const OutputFrequencyType& outputFrequency,
                  const DisableOutputType& disableOutput,
                  const LoggerConfigFileType& loggerConfigFile,
                  const OutputFilePrefixType& outputFilePrefix,
                  const OutputFileTypeType& outputFileType,
                  ::std::auto_ptr< TypeListType >& typeList,
                  ::std::auto_ptr< GeneratorType >& generator)
: ::xml_schema::Type (),
  deltaT_ (deltaT, ::xml_schema::Flags (), this),
  endTime_ (endTime, ::xml_schema::Flags (), this),
  dimensions_ (::xml_schema::Flags (), this),
  scenarioType_ (scenarioType, ::xml_schema::Flags (), this),
  domainSize_ (domainSize, ::xml_schema::Flags (), this),
  cutoffRadius_ (cutoffRadius, ::xml_schema::Flags (), this),
  boundaryHandling_ (boundaryHandling, ::xml_schema::Flags (), this),
  containerType_ (containerType, ::xml_schema::Flags (), this),
  gravitation_ (::xml_schema::Flags (), this),
  outputFrequency_ (outputFrequency, ::xml_schema::Flags (), this),
  disableOutput_ (disableOutput, ::xml_schema::Flags (), this),
  loggerConfigFile_ (loggerConfigFile, ::xml_schema::Flags (), this),
  outputFilePrefix_ (outputFilePrefix, ::xml_schema::Flags (), this),
  outputFileIterationOffset_ (::xml_schema::Flags (), this),
  outputFileType_ (outputFileType, ::xml_schema::Flags (), this),
  saveLastState_ (::xml_schema::Flags (), this),
  inputFile_ (::xml_schema::Flags (), this),
  thermostatSwitch_ (::xml_schema::Flags (), this),
  thermostatSettings_ (::xml_schema::Flags (), this),
  typeList_ (typeList, ::xml_schema::Flags (), this),
  forceField_ (::xml_schema::Flags (), this),
  generator_ (generator, ::xml_schema::Flags (), this)
{
}

SimulationConfig::
SimulationConfig (const SimulationConfig& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::Type (x, f, c),
  deltaT_ (x.deltaT_, f, this),
  endTime_ (x.endTime_, f, this),
  dimensions_ (x.dimensions_, f, this),
  scenarioType_ (x.scenarioType_, f, this),
  domainSize_ (x.domainSize_, f, this),
  cutoffRadius_ (x.cutoffRadius_, f, this),
  boundaryHandling_ (x.boundaryHandling_, f, this),
  containerType_ (x.containerType_, f, this),
  gravitation_ (x.gravitation_, f, this),
  outputFrequency_ (x.outputFrequency_, f, this),
  disableOutput_ (x.disableOutput_, f, this),
  loggerConfigFile_ (x.loggerConfigFile_, f, this),
  outputFilePrefix_ (x.outputFilePrefix_, f, this),
  outputFileIterationOffset_ (x.outputFileIterationOffset_, f, this),
  outputFileType_ (x.outputFileType_, f, this),
  saveLastState_ (x.saveLastState_, f, this),
  inputFile_ (x.inputFile_, f, this),
  thermostatSwitch_ (x.thermostatSwitch_, f, this),
  thermostatSettings_ (x.thermostatSettings_, f, this),
  typeList_ (x.typeList_, f, this),
  forceField_ (x.forceField_, f, this),
  generator_ (x.generator_, f, this)
{
}

SimulationConfig::
SimulationConfig (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
: ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
  deltaT_ (f, this),
  endTime_ (f, this),
  dimensions_ (f, this),
  scenarioType_ (f, this),
  domainSize_ (f, this),
  cutoffRadius_ (f, this),
  boundaryHandling_ (f, this),
  containerType_ (f, this),
  gravitation_ (f, this),
  outputFrequency_ (f, this),
  disableOutput_ (f, this),
  loggerConfigFile_ (f, this),
  outputFilePrefix_ (f, this),
  outputFileIterationOffset_ (f, this),
  outputFileType_ (f, this),
  saveLastState_ (f, this),
  inputFile_ (f, this),
  thermostatSwitch_ (f, this),
  thermostatSettings_ (f, this),
  typeList_ (f, this),
  forceField_ (f, this),
  generator_ (f, this)
{
  if ((f & ::xml_schema::Flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void SimulationConfig::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::Flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // deltaT
    //
    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      if (!deltaT_.present ())
      {
        this->deltaT_.set (DeltaTTraits::create (i, f, this));
        continue;
      }
    }

    // endTime
    //
    if (n.name () == "endTime" && n.namespace_ ().empty ())
    {
      if (!endTime_.present ())
      {
        this->endTime_.set (EndTimeTraits::create (i, f, this));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      if (!this->dimensions_)
      {
        this->dimensions_.set (DimensionsTraits::create (i, f, this));
        continue;
      }
    }

    // scenarioType
    //
    if (n.name () == "scenarioType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ScenarioTypeType > r (
        ScenarioTypeTraits::create (i, f, this));

      if (!scenarioType_.present ())
      {
        this->scenarioType_.set (r);
        continue;
      }
    }

    // domainSize
    //
    if (n.name () == "domainSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DomainSizeType > r (
        DomainSizeTraits::create (i, f, this));

      if (!domainSize_.present ())
      {
        this->domainSize_.set (r);
        continue;
      }
    }

    // cutoffRadius
    //
    if (n.name () == "cutoffRadius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CutoffRadiusType > r (
        CutoffRadiusTraits::create (i, f, this));

      if (!cutoffRadius_.present ())
      {
        this->cutoffRadius_.set (r);
        continue;
      }
    }

    // boundaryHandling
    //
    if (n.name () == "boundaryHandling" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BoundaryHandlingType > r (
        BoundaryHandlingTraits::create (i, f, this));

      if (!boundaryHandling_.present ())
      {
        this->boundaryHandling_.set (r);
        continue;
      }
    }

    // containerType
    //
    if (n.name () == "containerType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ContainerTypeType > r (
        ContainerTypeTraits::create (i, f, this));

      if (!containerType_.present ())
      {
        this->containerType_.set (r);
        continue;
      }
    }

    // gravitation
    //
    if (n.name () == "gravitation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< GravitationType > r (
        GravitationTraits::create (i, f, this));

      if (!this->gravitation_)
      {
        this->gravitation_.set (r);
        continue;
      }
    }

    // outputFrequency
    //
    if (n.name () == "outputFrequency" && n.namespace_ ().empty ())
    {
      if (!outputFrequency_.present ())
      {
        this->outputFrequency_.set (OutputFrequencyTraits::create (i, f, this));
        continue;
      }
    }

    // disableOutput
    //
    if (n.name () == "disableOutput" && n.namespace_ ().empty ())
    {
      if (!disableOutput_.present ())
      {
        this->disableOutput_.set (DisableOutputTraits::create (i, f, this));
        continue;
      }
    }

    // loggerConfigFile
    //
    if (n.name () == "loggerConfigFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LoggerConfigFileType > r (
        LoggerConfigFileTraits::create (i, f, this));

      if (!loggerConfigFile_.present ())
      {
        this->loggerConfigFile_.set (r);
        continue;
      }
    }

    // outputFilePrefix
    //
    if (n.name () == "outputFilePrefix" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OutputFilePrefixType > r (
        OutputFilePrefixTraits::create (i, f, this));

      if (!outputFilePrefix_.present ())
      {
        this->outputFilePrefix_.set (r);
        continue;
      }
    }

    // outputFileIterationOffset
    //
    if (n.name () == "outputFileIterationOffset" && n.namespace_ ().empty ())
    {
      if (!this->outputFileIterationOffset_)
      {
        this->outputFileIterationOffset_.set (OutputFileIterationOffsetTraits::create (i, f, this));
        continue;
      }
    }

    // outputFileType
    //
    if (n.name () == "outputFileType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OutputFileTypeType > r (
        OutputFileTypeTraits::create (i, f, this));

      if (!outputFileType_.present ())
      {
        this->outputFileType_.set (r);
        continue;
      }
    }

    // saveLastState
    //
    if (n.name () == "saveLastState" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SaveLastStateType > r (
        SaveLastStateTraits::create (i, f, this));

      if (!this->saveLastState_)
      {
        this->saveLastState_.set (r);
        continue;
      }
    }

    // inputFile
    //
    if (n.name () == "inputFile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InputFileType > r (
        InputFileTraits::create (i, f, this));

      if (!this->inputFile_)
      {
        this->inputFile_.set (r);
        continue;
      }
    }

    // thermostatSwitch
    //
    if (n.name () == "thermostatSwitch" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ThermostatSwitchType > r (
        ThermostatSwitchTraits::create (i, f, this));

      if (!this->thermostatSwitch_)
      {
        this->thermostatSwitch_.set (r);
        continue;
      }
    }

    // thermostatSettings
    //
    if (n.name () == "thermostatSettings" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ThermostatSettingsType > r (
        ThermostatSettingsTraits::create (i, f, this));

      if (!this->thermostatSettings_)
      {
        this->thermostatSettings_.set (r);
        continue;
      }
    }

    // typeList
    //
    if (n.name () == "typeList" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TypeListType > r (
        TypeListTraits::create (i, f, this));

      if (!typeList_.present ())
      {
        this->typeList_.set (r);
        continue;
      }
    }

    // forceField
    //
    if (n.name () == "forceField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ForceFieldType > r (
        ForceFieldTraits::create (i, f, this));

      this->forceField_.push_back (r);
      continue;
    }

    // generator
    //
    if (n.name () == "generator" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< GeneratorType > r (
        GeneratorTraits::create (i, f, this));

      if (!generator_.present ())
      {
        this->generator_.set (r);
        continue;
      }
    }

    break;
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deltaT",
      "");
  }

  if (!endTime_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "endTime",
      "");
  }

  if (!scenarioType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "scenarioType",
      "");
  }

  if (!domainSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSize",
      "");
  }

  if (!cutoffRadius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoffRadius",
      "");
  }

  if (!boundaryHandling_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryHandling",
      "");
  }

  if (!containerType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "containerType",
      "");
  }

  if (!outputFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputFrequency",
      "");
  }

  if (!disableOutput_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disableOutput",
      "");
  }

  if (!loggerConfigFile_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "loggerConfigFile",
      "");
  }

  if (!outputFilePrefix_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputFilePrefix",
      "");
  }

  if (!outputFileType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputFileType",
      "");
  }

  if (!typeList_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "typeList",
      "");
  }

  if (!generator_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "generator",
      "");
  }
}

SimulationConfig* SimulationConfig::
_clone (::xml_schema::Flags f,
        ::xml_schema::Container* c) const
{
  return new class SimulationConfig (*this, f, c);
}

SimulationConfig::
~SimulationConfig ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::SimulationConfig >
simulationConfig (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::SimulationConfig > r (
    ::simulationConfig (
      d, f | ::xml_schema::Flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimulationConfig > r (
    ::simulationConfig (
      d, f | ::xml_schema::Flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimulationConfig > r (
    ::simulationConfig (
      d, f | ::xml_schema::Flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulationConfig (isrc, f, p);
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulationConfig (isrc, h, f, p);
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::simulationConfig (isrc, h, f, p);
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulationConfig (isrc, f, p);
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::Flags::dont_initialize) == 0,
    (f & ::xml_schema::Flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulationConfig (isrc, h, f, p);
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::simulationConfig (isrc, h, f, p);
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::SimulationConfig > r (
    ::simulationConfig (
      d, f | ::xml_schema::Flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimulationConfig > r (
    ::simulationConfig (
      d, f | ::xml_schema::Flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimulationConfig > r (
    ::simulationConfig (
      d, f | ::xml_schema::Flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (const ::xercesc::DOMDocument& d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
{
  if (f & ::xml_schema::Flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::SimulationConfig > r (
      ::simulationConfig (
        c, f | ::xml_schema::Flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "simulationConfig" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SimulationConfig > r (
      ::xsd::cxx::tree::traits< ::SimulationConfig, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulationConfig",
    "");
}

::std::auto_ptr< ::SimulationConfig >
simulationConfig (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::Flags::keep_dom) &&
     !(f & ::xml_schema::Flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::Flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "simulationConfig" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SimulationConfig > r (
      ::xsd::cxx::tree::traits< ::SimulationConfig, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "simulationConfig",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

